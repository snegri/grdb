diff --git a/include/graph.h b/include/graph.h
index 46a1fca..279a6c2 100644
--- a/include/graph.h
+++ b/include/graph.h
@@ -66,16 +66,16 @@ void vertex_init(vertex_t v);
 int vertex_file_init(int gidx, int cidx);
 void vertex_set_id(vertex_t v, vertexid_t id);
 void vertex_print(vertex_t v);
-ssize_t vertex_read(vertex_t v, schema_t schema, int fd);
-ssize_t vertex_write(vertex_t v, int fd);
+size_t vertex_read(vertex_t v, schema_t schema, int fd);
+size_t vertex_write(vertex_t v, int fd);
 
 
 void edge_init(edge_t e);
 int edge_file_init(int gidx, int cidx);
 void edge_set_vertices(edge_t e, vertexid_t id1, vertexid_t id2);
 void edge_print(edge_t e);
-ssize_t edge_read(edge_t e, schema_t schema, int fd);
-ssize_t edge_write(edge_t e, int fd);
+size_t edge_read(edge_t e, schema_t schema, int fd);
+size_t edge_write(edge_t e, int fd);
 
 void component_init(component_t c);
 void component_file_init(int gidx, int cidx);
diff --git a/src/db/component_sssp.c b/src/db/component_sssp.c
index 0691434..0c32d0d 100644
--- a/src/db/component_sssp.c
+++ b/src/db/component_sssp.c
@@ -1,33 +1,292 @@
+#include <assert.h>
+#include <stdio.h>
+#include <string.h>
+#include <string.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <limits.h>
+#include "config.h"
+#include "cli.h"
 #include "graph.h"
+#define INT_type 4
+#define inf INT_MAX
 
 
-/* Place the code for your Dijkstra implementation in this file */
+int get_weight(component_t c, vertexid_t v1, vertexid_t v2, char attr_name[]) {
+	struct edge e;
+	edge_t e1;
+	int offset, weight;
 
+	edge_init(&e);
+	edge_set_vertices(&e, v1, v2);
 
-int
-component_sssp(
+	e1 = component_find_edge_by_ids(c, &e);
+
+
+	if(e1 == NULL) {
+		return inf;
+	}
+
+	offset = tuple_get_offset(e1->tuple, attr_name);
+	weight = tuple_get_int(e1->tuple->buf + offset);
+
+	return weight;
+
+}
+
+int get_number_of_vertices(component_t c) {
+	off_t off;
+	ssize_t len, size;
+	vertexid_t v;
+	struct tuple tuple;
+	char *buf;
+	int readlen;
+
+
+	//assert (c != NULL);
+
+	/* Vertices */
+	if (c->sv == NULL)
+		size = 0;
+	else
+		size = schema_size(c->sv);
+
+	readlen = sizeof(vertexid_t) + size;
+	buf = malloc(readlen);
+
+	int count = 0;
+	for (off = 0;; off += readlen) {
+		lseek(c->vfd, off, SEEK_SET);
+		len = read(c->vfd, buf, readlen);
+		if (len <= 0)
+			break;
+
+		v = *((vertexid_t *) buf);
+		count++;
+	}
+
+	free(buf);
+
+	return count; 
+
+}
+
+
+int get_vertices(component_t c, vertexid_t list[]) {
+	off_t off;
+	ssize_t len, size;
+	vertexid_t v;
+	struct tuple tuple;
+	char *buf;
+	int readlen;
+
+
+	//assert (c != NULL);
+
+	/* Vertices */
+	if (c->sv == NULL)
+		size = 0;
+	else
+		size = schema_size(c->sv);
+
+	readlen = sizeof(vertexid_t) + size;
+	buf = malloc(readlen);
+
+	int i = 0;
+	int count = 0;
+	for (off = 0;; off += readlen) {
+		lseek(c->vfd, off, SEEK_SET);
+		len = read(c->vfd, buf, readlen);
+		if (len <= 0)
+			break;
+
+		v = *((vertexid_t *) buf);
+		list[i] = v;
+		i++;
+		count++;
+	}
+
+	free(buf);
+
+	return count; 
+
+}
+
+void print_vertices(vertexid_t list[], int number_of_vertices) {
+	for (int i = 0; i < number_of_vertices; i++) {
+
+		if (i == 2) {
+			printf("%llu",list[i] );
+		}
+		else {
+			printf("%llu,",list[i]);
+		}
+	}
+	printf("\n");
+}
+
+
+
+int component_sssp(
         component_t c,
         vertexid_t v1,
         vertexid_t v2,
         int *n,
         int *total_weight,
         vertexid_t **path)
-{
+{ 		
+	c->efd = edge_file_init(gno,cno);
+	c->vfd = vertex_file_init(gno, cno);
+
+	attribute_t attr;
 	
-	/*
-	 * Figure out which attribute in the component edges schema you will
-	 * use for your weight function
-	 */
+	for(attr = c->se->attrlist; attr != NULL; attr = attr->next) {
+		if (attr->bt == INT_type)
+		{
+			break;
+		}
+	}
+
+	int number_of_vertices = get_number_of_vertices(c);
+	vertexid_t *vertex_list;
+	vertex_list = (vertexid_t *)malloc(sizeof(vertexid_t) * number_of_vertices);
+
+	get_vertices(c, vertex_list);
+	//print_vertices(vertex_list, number_of_vertices);
+
+
+	//Make S list
+	vertexid_t *S;
+	S = (vertexid_t *)malloc(sizeof(vertexid_t) * (number_of_vertices+1));
+
+	//Make V list
+	vertexid_t *V;
+	V = (vertexid_t *)malloc(sizeof(vertexid_t) * (number_of_vertices+1));
 
+	vertexid_t *P;
+	P = (vertexid_t *)malloc(sizeof(vertexid_t) * (number_of_vertices+1));
 
 
-	/*
-	 * Execute Dijkstra on the attribute you found for the specified
-	 * component
-	 */
+	//Make D list
+	int *D;
+	D = (int *)malloc(sizeof(int) * (number_of_vertices+1));
 
+	for (int i = 0; i <= number_of_vertices; i++) {
+		if (i == 0)
+		{
+			V[i] = 0;
+		}
+		V[i+1] = vertex_list[i];
+		D[i] = INT_MAX;
+		//printf("%d\n", D[i]);
+	}
 
 
-	/* Change this as needed */
-	return (-1);
+	//int weight = 0;
+	//weight = get_weight(c, v1, v2, attr->name);
+	//printf("Weight is: %d\n", weight);
+
+	S[0] = v1;
+	int count = 1;
+	int min = 0;
+	int indexW = 0;
+	vertexid_t reset;
+	for (int i = 2; i <= number_of_vertices; i++)
+	{
+
+		for (int i = 2; i <= number_of_vertices; ++i)
+		{
+			S[i] = reset;
+			printf("S: %llu\n", S[i]);
+		}
+		printf("\n");
+
+		min = INT_MAX;
+		int isItInS = 0;
+		vertexid_t next = V[i];
+		D[i] = get_weight(c, v1, next, attr->name);
+		//printf("%llu\n", S[1]);
+
+		for (int i = 1; i <= number_of_vertices; i++)
+		{
+
+			if (D[i] < min)
+			{
+				for (int j = 1; j <= number_of_vertices; ++j)
+				{
+					if (i == S[j])
+					{
+						isItInS = 1;
+					}
+				}
+				if (isItInS == 0) {	
+					min = D[i];
+					indexW = i;
+				}
+			}
+		}
+		S[count] = V[indexW];
+		count++;
+
+		int inS = 0;
+		int weightWV = 0;
+		int indexV = 0;
+		for (int i = 1; i <= number_of_vertices; ++i)
+		{
+			inS = 0;
+			for (int j = 1; j <= number_of_vertices; ++j)
+			{
+				if (i == S[j])
+				{
+					inS = 1;
+				}
+			}
+			if (inS == 1)
+			{
+				continue;
+			}
+			indexV = i; 
+			weightWV = get_weight(c, V[indexW], V[i], attr->name);
+			
+			if (D[indexW] + weightWV < D[i])
+			{
+				P[indexV] = V[indexW]; 
+				//printf("%llu\n", P[indexV]);
+			}
+			int minumum = 0;
+			if (D[indexW] + weightWV < D[indexV])
+			{
+				minumum = D[indexW] + weightWV;
+				
+			}
+			else {
+				minumum = D[indexV];
+			}
+			printf("%d\n", minumum);
+			D[indexV] = minumum;
+		}
+
+		/* Print Statements */
+
+		for (int i = 1; i <= number_of_vertices; ++i)
+		{
+			printf("Parent List: %llu, ", P[i]);
+		}
+
+		printf("\n");
+		for (int i = 1; i <= number_of_vertices; ++i)
+		{
+			printf("Cost list: %d, ", D[i]);
+		}
+		printf("\n");
+	}
+
+	free(D);
+	free(V);
+	free(S);
+	return -1;
+
 }
+	
+
diff --git a/src/db/edge.c b/src/db/edge.c
index a956744..30d1743 100644
--- a/src/db/edge.c
+++ b/src/db/edge.c
@@ -8,6 +8,7 @@
 #include <string.h>
 #include "config.h"
 #include "graph.h"
+#include "cli.h"
 
 void
 edge_init(edge_t e)
@@ -25,7 +26,7 @@ edge_file_init(int gidx, int cidx)
 
 	/* Create component edge file */
 	memset(s, 0, BUFSIZE);
-	sprintf(s, "%s/%d/%d/e", GRDBDIR, gidx, cidx);
+	sprintf(s, "%s/%d/%d/e", grdbdir, gidx, cidx);
 #if _DEBUG
 	printf("edge_file_init: open edge file %s\n", s);
 #endif
diff --git a/src/db/edge_read.c b/src/db/edge_read.c
index 82c22d5..acbc13b 100644
--- a/src/db/edge_read.c
+++ b/src/db/edge_read.c
@@ -14,7 +14,7 @@
  * zero means the end-of-file was reached.  Otherwise, the number of bytes
  * read in for the vertex tuple are returned.
  */
-ssize_t
+size_t
 edge_read(edge_t e, schema_t schema, int fd)
 {
 	off_t off;
diff --git a/src/db/edge_write.c b/src/db/edge_write.c
index a8542ef..2dfb8bd 100644
--- a/src/db/edge_write.c
+++ b/src/db/edge_write.c
@@ -11,7 +11,7 @@
  * 64-bit vertex ids followed by the edge tuple.  Assume the ids and tuple
  * are set to be written.
  */
-ssize_t
+size_t
 edge_write(edge_t e, int fd)
 {
 	off_t off;
diff --git a/src/db/vertex.c b/src/db/vertex.c
index dc8d122..6761971 100644
--- a/src/db/vertex.c
+++ b/src/db/vertex.c
@@ -7,6 +7,7 @@
 #include <string.h>
 #include "config.h"
 #include "graph.h"
+#include "cli.h"
 
 /* Clear the vertex data structure */
 void
@@ -25,7 +26,7 @@ vertex_file_init(int gidx, int cidx)
 
 	/* Create component vertex file */
 	memset(s, 0, BUFSIZE);
-	sprintf(s, "%s/%d/%d/v", GRDBDIR, gidx, cidx);
+	sprintf(s, "%s/%d/%d/v", grdbdir, gidx, cidx);
 #if _DEBUG
 	printf("vertex_file_init: open vertex file %s\n", s);
 #endif
diff --git a/src/db/vertex_read.c b/src/db/vertex_read.c
index 852b877..28d873e 100644
--- a/src/db/vertex_read.c
+++ b/src/db/vertex_read.c
@@ -14,7 +14,7 @@
  * zero means the end-of-file was reached.  Otherwise, the number of bytes
  * read in for the vertex tuple are returned.
  */
-ssize_t
+size_t
 vertex_read(vertex_t v, schema_t schema, int fd)
 {
 	off_t off;
diff --git a/src/db/vertex_write.c b/src/db/vertex_write.c
index 9a8a154..4c8d855 100644
--- a/src/db/vertex_write.c
+++ b/src/db/vertex_write.c
@@ -11,7 +11,7 @@
  * 64-bit vertex id followed by the vertex tuple.  Assume the id and tuple
  * are set to be written.
  */
-ssize_t
+size_t
 vertex_write(vertex_t v, int fd)
 {
 	off_t off;
